import java.util.*;

/**
 *  Contains the maze struture, which is just an array of 
 *  <code>MazeCell</code>s.  Also contains the algorithms
 *  for generating and solving the maze.
 *
 */
public class Maze {
	private Scanner in;
	private Random generator;
	private int rows, cols, wallDestructions, time;
	private ArrayList<MazeCell> allCells, traversedCells;
	private MazeViewer viewer;
	private MazeCell startCell, endCell, current, maze[][];
	private DisjointSet ds;
	private Queue<MazeCell> q;

	/**
	 *  Creates a maze that has the given number of rows and columns.
	 *  Sets the neighbors of each cell.
	 *  @param rows  Number of rows in the maze.
	 *  @param cols  Number of columns in the maze.
	 */
	public Maze(int rows, int cols) {
		this.rows = rows;
		this.cols = cols;
		generator = new Random();
		wallDestructions = 0;
		current = new MazeCell();
		ds = new DisjointSet();
		allCells = new ArrayList<MazeCell>();
		traversedCells = new ArrayList<MazeCell>();

		// Create the maze.     
		maze = new MazeCell[rows][cols];
		for (int i=0; i<rows; i++) {
			for (int j=0; j<cols; j++) {
				maze[i][j] = new MazeCell();
			}
		}

		// Set the neighbors for each cell in the maze.
		for (int i=0; i<rows; i++) {
			for (int j=0; j<cols; j++) {
				MazeCell n, e, s, w;
				if (i == 0) n = null; // On north border of maze
				else n = maze[i-1][j]; 

				if (i == rows-1) s = null; // On south border of maze
				else s = maze[i+1][j];

				if (j == 0) w = null; // On west border of maze
				else w = maze[i][j-1];

				if (j == cols-1) e = null; // On east border of maze
				else e = maze[i][j+1];

				maze[i][j].setNeighbors(n,e,s,w);
			}
		}

	}


	/**
	 *  Accessor that sets the <code>MazeViewer</code> variable for
	 *  the maze.  When the viewer is not set, no visualization takes place.
	 *  @param viewer Visual display place for the maze.
	 */
	public void setViewer(MazeViewer viewer) {
		this.viewer = viewer;
	}

	/**
	 *  Accessor that sets the start cell for the maze.
	 *  @param cell Start cell for the maze.
	 */
	public void setStartCell(MazeCell cell) {
		startCell = cell;
	}

	/**
	 *  Accessor that sets the end cell for the maze.
	 *  @param cell End cell for the maze.
	 */
	public void setEndCell(MazeCell cell) {
		endCell = cell;
	}

	/**
	 *  Accessor that returns the start cell for the maze.
	 *  @return Start cell for the maze.
	 */
	public MazeCell getStartCell() {
		return startCell;
	}

	/**
	 *  Accessor that returns the end cell for the maze.
	 *  @return End cell for the maze.
	 */
	public MazeCell getEndCell() {
		return endCell;
	}

	/**
	 *  Accessor that returns the number of rows in the maze.
	 *  @return The number of rows in the maze.
	 */
	public int getRows() {
		return rows;
	}

	/**
	 *  Accessor that returns the number of columns in the maze.
	 *  @return The number of columns in the maze.
	 */
	public int getCols() {
		return cols;
	}

	/**
	 *  Returns the cell in the maze at the given coordinates.
	 *  @param row  The row in the maze of the cell.
	 *  @param col  The column in the maze of the cell.
	 *  @return  The cell at (<code>row</code>, <code>col</code>)
	 */
	public MazeCell getCell(int row, int col) {
		MazeCell target = new MazeCell();
		try{
			target = maze[row][col];
		} catch (IndexOutOfBoundsException ioobe){
			System.out.println("Indices provided are outside of matrix!");
		}
		return target;
	}

	/**
	 *  Tells the viewer to show the maze again, with 
	 *  any changes to cells updated.  The current cell 
	 *  will be colored in the viewer.  If the viewer is null,
	 *  this method does nothing.
	 *  @param cell Current cell, that the viewer will color.
	 */
	public synchronized void visualize(MazeCell cell) {
		viewer.visualize(cell);
	}

	/**
	 *  Generates the maze. 
	 *  The maze is generated by Kruskal's algorithm
	 */
	public synchronized void generateMaze() {
		makeKruskalMaze();
		//you can change the startCell and endCell values
		startCell = maze[0][0];
		endCell = maze[rows-1][cols-1];
	}


	/**
	 *  Forms the maze via Kruskal's algorithm.
	 */
	public synchronized void makeKruskalMaze() {
		ds.makeSet(maze);
		ArrayList<MazeCell> allCellSets = ds.getAllSetMembers();
		ArrayList<MazeCell> neighbors = new ArrayList<MazeCell>();
		int round = 1;
		current = new MazeCell();
		current = maze[0][0];
		MazeCell neighbor = new MazeCell();
		int totalCells = (getRows() * getCols());

		//start of modified Kruskal's algorithm
		while(wallDestructions < totalCells - 1) {
			if(round > 1) { //first iteration we use starting point maze[0][0], after choose random cell
				int bound = allCellSets.size();
				int index = generator.nextInt(bound);
				current = allCellSets.get(index); //choose random current cell
			}
			neighbors = current.getNeighbors(current); //get list of current's neighbors
			for(MazeCell adj : neighbors){
				if(current.sharesWallWith(current, adj)){ //choose random neighbor of current w/ wall btwn it and current
					neighbor = adj;
					if(ds.findSet(current) != ds.findSet(neighbor)){
						ds.union(current, neighbor);
						current.knockDownWall(current, neighbor);
						wallDestructions = wallDestructions + 1;
					}
					break;
				}
			}

			round = round + 1;
		} //end of Min Spanning Tree forming algorithm/Kruskal's modification
	}

	/**
	 *  Solve maze.  The input parameter is guaranteed
	 *  to be one of "dfs", "bfs",  or "random".
	 *  @param method The method for solving the maze; one of
	 *                "dfs" = depth first search, 
	 *                "bfs" = breadth first search, 
	 *                "random" = random walk.
	 */
	public synchronized void solveMaze(String method) {
		if(method.contains("dfs") || method.equalsIgnoreCase("dfs")){
			solveDFSMaze();
		} else if (method.contains("bfs") || method.equalsIgnoreCase("bfs")){
			solveBFSMaze();
		} else if (method.contains("random") || method.equalsIgnoreCase("random")){
			solveRandomMaze();
		} else {
			System.out.println("Please input a valid parameter: 'dfs', 'bfs', or 'random'");
			in = new Scanner(System.in);
			String input = in.next();
			solveMaze(input);
		}
	}

	/**
	 *  Solves the maze by randomly choosing a neighboring
	 *  cell to explore. This method has been written for you.
	 *  Please note this method takes a very long time
	 *  to complete.
	 */
	public synchronized void solveRandomMaze() {
		// Start the search at the start cell
		MazeCell current = startCell;

		// while we haven't reached the end of the maze
		while(current != endCell) { 
			visualize(current); // show the progress visually (repaint)
			ArrayList<MazeCell> neighbors = current.getNeighbors(current);
			int index = generator.nextInt(neighbors.size());
			current.examine();
			current = neighbors.get(index);    
		}
		visualize(current);
	}

	/**<<<<<<<MAIN DFS>>>>>>>>
	 *  Solves the maze by depth first search.
	 */
	public synchronized void solveDFSMaze() {
		MazeCell current = startCell;
		runDFS(current);
	}

	/**<<<<<<<DFS>>>>>>>>>
	 * The primary method that implements the DFSvisit method
	 * @param start a MazeCell start value
	 */
	public void runDFS(MazeCell start) {
		MazeCell current = start;
		allCells = ds.getAllSetMembers();
		for(MazeCell mc : allCells){
			//			mc.color = "white";
			mc.predecessor = null;
		}
		time = 0;

		if(current != null){
			visualize(current);
			current.examine();
			DFSvisit(allCells, current);
		}

		for(MazeCell cell : allCells){
			if(cell.visited() == false){ //!cell.visited() == !color.equals("white")
				DFSvisit(allCells, cell);
			}
		}
		System.out.println("DFS has finished!");
	}

	/**<<<<<<<DFS RECURSIVE CALL>>>>>
	 * The recursive method that forms part of the overall DFS running
	 * @param allCells a list of all MazeCell objects in graph
	 * @param current the current MazeCell being discovered
	 * 
	 * current = 'u' ; c = 'v'
	 */
	public void DFSvisit(List<MazeCell> listOfCells, MazeCell current) {
		time = time + 1;
		current.start = time;
		//		current.color = "gray";
		current.visit(); //paint yellow

		if (current != endCell) { 
			visualize(current); 
		}

		ArrayList<MazeCell> neighbors = current.getNeighbors(current);
		for(MazeCell unVecino : neighbors){
			if (current.sharesWallWith(current, unVecino) == false){
				if (unVecino.visited() == false){
					unVecino.predecessor = current;
					DFSvisit(allCells, unVecino);
				}
			}
		}

		//original CLRS implementation (part)
		//need to iterate over all adjacencies to current cell
		//		if(adjacencies != null){
		//			for(MazeCell c : adjacencies){
		//				if(c != null){
		//					if(c.color.equalsIgnoreCase("white")){
		//						c.predecessor = current;
		//						DFSvisit(allCells, c);
		//					}
		//				}
		//			}
		//		}
		//		current.color = "black";

		current.examine();
		time = time + 1;
		current.finish = time;
	}


	/** <<<<<<<<BFS>>>>>>>>>>>>>>
	 *  Solves the maze by breadth first search.
	 *  starts at the start vertex and stops when bfs
	 *  discovers the end vertex
	 */
	public synchronized void solveBFSMaze() {
		q = new LinkedList<>();
		LinkedList<MazeCell> adjacencies = new LinkedList<>();
		allCells = ds.getAllSetMembers();
		for(MazeCell cellName : allCells) { 
			cellName.color = "white";
			cellName.distance = 0;
			cellName.predecessor = null;
		}
		startCell.color = "white";
		startCell.distance = 0;
		startCell.predecessor = null;

		MazeCell u = startCell;
		q.add(startCell);

		while(q.isEmpty() == false && u != endCell){
			u = q.remove();
			visualize(u); // show the progress visually (repaint)
			ArrayList<MazeCell> neighbors = u.getNeighbors(u);
			for(MazeCell vecino : neighbors){
				if(!u.sharesWallWith(u, vecino) && !traversedCells.contains(vecino)){
					//				if(!u.sharesWallWith(u, vecino)){
					q.add(vecino);
				} else if (traversedCells.contains(vecino)){
					vecino.examine();
				}
			}
			u.visit();
			traversedCells.add(u);

			//ORIGINAL CLRS implementation of BFS
			/*
			if(u.neighborE != null && u.east() == false){
				adjacencies.add(u.neighborE);
			} else if (u.neighborN != null && u.north() == false){
				adjacencies.add(u.neighborN);
			}else if (u.neighborS != null && u.south() == false){
				adjacencies.add(u.neighborN);
			}else if (u.neighborW != null && u.west() == false){
				adjacencies.add(u.neighborN);
			}
			 */

			//			if(!traversedCells.contains(currentCell)){
			//				q.add(currentCell);
			//			}

			//			if(adjacencies != null){
			//				for(MazeCell cell : adjacencies){
			//					if(cell != null){
			//						MazeCell currentCell = new MazeCell();
			//						currentCell = cell;
			//						if(currentCell.color.equals("white")){
			//							currentCell.color = "gray";
			//							currentCell.distance = u.distance + 1;
			//							currentCell.predecessor = u;
			//							//						System.out.println("node: " + currentNode.value + ", node distance:" + currentNode.distance + " , predecessor: " + currentNode.predecessor.value);
			//							if(!traversedCells.contains(currentCell)){
			//								q.add(currentCell);
			//							}
			//						}
			//						adjacencies.remove(cell);
			//					}
			//				}
			//			}
			//			u.color = "black";
			//			u.examine();
		}
		System.out.println("BFS has finished running!");	
	}


}
