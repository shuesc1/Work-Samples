//package maze;


import java.util.*;

/**
 *  Contains the maze struture, which is just an array of 
 *  <code>MazeCell</code>s.  Also contains the algorithms
 *  for generating and solving the maze.
 *
 */
public class Maze {

	private int rows, cols;
	private MazeCell maze[][];
	//the UI code is all in MazeViewer.java
	private MazeViewer viewer;
	//This is just for random number generation
	private Random generator;
	private MazeCell startCell;
	private MazeCell endCell;
	private Scanner in;

	/**
	 *  Creates a maze that has the given number of rows and columns.
	 *  Sets the neighbors of each cell.
	 *  @param rows  Number of rows in the maze.
	 *  @param cols  Number of columns in the maze.
	 */
	public Maze(int rows, int cols) {
		this.rows = rows;
		this.cols = cols;
		generator = new Random();

		// Create the maze.     
		maze = new MazeCell[rows][cols];
		for (int i=0; i<rows; i++) {
			for (int j=0; j<cols; j++) {
				maze[i][j] = new MazeCell();
			}
		}

		// Set the neighbors for each cell in the maze.
		for (int i=0; i<rows; i++) {
			for (int j=0; j<cols; j++) {
				MazeCell n, e, s, w;
				if (i == 0) n = null; // On north border of maze
				else n = maze[i-1][j]; 

				if (i == rows-1) s = null; // On south border of maze
				else s = maze[i+1][j];

				if (j == 0) w = null; // On west border of maze
				else w = maze[i][j-1];

				if (j == cols-1) e = null; // On east border of maze
				else e = maze[i][j+1];

				maze[i][j].setNeighbors(n,e,s,w);
			}
		}
	}


	/**
	 *  Accessor that sets the <code>MazeViewer</code> variable for
	 *  the maze.  When the viewer is not set, no visualization takes place.
	 *  @param viewer Visual display place for the maze.
	 */
	public void setViewer(MazeViewer viewer) {
		this.viewer = viewer;
	}

	/**
	 *  Accessor that sets the start cell for the maze.
	 *  @param cell Start cell for the maze.
	 */
	public void setStartCell(MazeCell cell) {
		startCell = cell;
	}

	/**
	 *  Accessor that sets the end cell for the maze.
	 *  @param cell End cell for the maze.
	 */
	public void setEndCell(MazeCell cell) {
		endCell = cell;
	}

	/**
	 *  Accessor that returns the start cell for the maze.
	 *  @return Start cell for the maze.
	 */
	public MazeCell getStartCell() {
		return startCell;
	}

	/**
	 *  Accessor that returns the end cell for the maze.
	 *  @return End cell for the maze.
	 */
	public MazeCell getEndCell() {
		return endCell;
	}

	/**
	 *  Accessor that returns the number of rows in the maze.
	 *  @return The number of rows in the maze.
	 */
	public int getRows() {
		return rows;
	}

	/**
	 *  Accessor that returns the number of columns in the maze.
	 *  @return The number of columns in the maze.
	 */
	public int getCols() {
		return cols;
	}

	/**
	 *  Returns the cell in the maze at the given coordinates.
	 *  @param row  The row in the maze of the cell.
	 *  @param col  The column in the maze of the cell.
	 *  @return  The cell at (<code>row</code>, <code>col</code>)
	 */
	public MazeCell getCell(int row, int col) {
		MazeCell target = new MazeCell();
		try{
			target = maze[row][col];
		} catch (IndexOutOfBoundsException ioobe){
			System.out.println("Indices provided are outside of matrix!");
		}
		return target;
	}

	/**
	 *  Tells the viewer to show the maze again, with 
	 *  any changes to cells updated.  The current cell 
	 *  will be colored in the viewer.  If the viewer is null,
	 *  this method does nothing.
	 *  @param cell Current cell, that the viewer will color.
	 */
	public synchronized void visualize(MazeCell cell) {
		//TODO - call the appropriate method from MazeViewer to visualize
	}

	/**
	 *  Generates the maze. 
	 *  The maze is generated by Kruskal's algorithm
	 */
	public synchronized void generateMaze() {
		makeKruskalMaze();
		//you can change the startCell and endCell values
		startCell = maze[0][0];
		endCell = maze[rows-1][cols-1];
	}


	/**
	 *  Forms the maze via Kruskal's algorithm.
	 */
	public synchronized void makeKruskalMaze() {
		//TODO - use a modified version of Kruskal's algorithm to make the maze
	}


	/**
	 *  Solve maze.  The input parameter is guaranteed
	 *  to be one of "dfs", "bfs",  or "random".
	 *  @param method The method for solving the maze; one of
	 *                "dfs" = depth first search, 
	 *                "bfs" = breadth first search, 
	 *                "random" = random walk.
	 */
	public synchronized void solveMaze(String method) {
		if(method.contains("dfs") || method.equalsIgnoreCase("dfs")){
			solveDFSMaze();
		} else if (method.contains("bfs") || method.equalsIgnoreCase("bfs")){
			solveBFSMaze();
		} else if (method.contains("random") || method.equalsIgnoreCase("random")){
			solveRandomMaze();
		} else {
			System.out.println("Please input a valid parameter: 'dfs', 'bfs', or 'random'");
			in = new Scanner(System.in);
			String input = in.next();
			solveMaze(input);
		}
	}

	/**
	 *  Solves the maze by randomly choosing a neighboring
	 *  cell to explore. This method has been written for you.
	 *  Please note this method takes a very long time
	 *  to complete.
	 */
	public synchronized void solveRandomMaze() {
		// Start the search at the start cell
		MazeCell current = startCell;

		// while we haven't reached the end of the maze
		while(current != endCell) { 
			visualize(current); // show the progress visually (repaint)
			ArrayList<MazeCell> neighbors = current.getNeighbors();
			int index = generator.nextInt(neighbors.size());
			current.examine();
			current = neighbors.get(index);    
		}
		visualize(current);
	}

	/**
	 *  Solves the maze by depth first search.
	 */
	public synchronized void solveDFSMaze() {
		// Start the search at the start cell
		MazeCell current = startCell;

		// while we haven't reached the end of the maze
		while(current != endCell) { 
			visualize(current); // show the progress visually (repaint)
			ArrayList<MazeCell> neighbors = current.getNeighbors();
			int index = generator.nextInt(neighbors.size());
			current.examine();
			current = neighbors.get(index);    
		}
		visualize(current);
	}

	/**
	 *  Solves the maze by breadth first search.
	 *  starts at the start vertex and stops when bfs
	 *  discovers the end vertex
	 */
	public synchronized void solveBFSMaze() {
		//TODO - do a BFS implementation
	}


}
